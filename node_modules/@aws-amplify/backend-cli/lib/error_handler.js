import { COLOR } from '@aws-amplify/cli-core';
import { InvalidCredentialError } from './error/credential_error.js';
import { printer } from './printer.js';
import { EOL } from 'os';
let hasAttachUnhandledExceptionListenersBeenCalled = false;
/**
 * Attaches process listeners to handle unhandled exceptions and rejections
 */
export const attachUnhandledExceptionListeners = () => {
    if (hasAttachUnhandledExceptionListenersBeenCalled) {
        return;
    }
    process.on('unhandledRejection', (reason) => {
        process.exitCode = 1;
        if (reason instanceof Error) {
            handleError(reason);
        }
        else if (typeof reason === 'string') {
            handleError(new Error(reason));
        }
        else {
            handleError(new Error(`Unhandled rejection of type [${typeof reason}]`, {
                cause: reason,
            }));
        }
    });
    process.on('uncaughtException', (error) => {
        process.exitCode = 1;
        handleError(error);
    });
    hasAttachUnhandledExceptionListenersBeenCalled = true;
};
/**
 * Generates a function that is intended to be used as a callback to yargs.fail()
 * All logic for actually handling errors should be delegated to handleError.
 *
 * For some reason the yargs object that is injected into the fail callback does not include all methods on the Argv type
 * This generator allows us to inject the yargs parser into the callback so that we can call parser.exit() from the failure handler
 * This prevents our top-level error handler from being invoked after the yargs error handler has already been invoked
 */
export const generateCommandFailureHandler = (parser) => {
    /**
     * Format error output when a command fails
     * @param message error message set by the yargs:check validations
     * @param error error thrown by yargs handler
     */
    const handleCommandFailure = (message, error) => {
        const printHelp = () => {
            printer.printNewLine();
            parser.showHelp();
            printer.printNewLine();
        };
        handleError(error, printHelp, message);
        parser.exit(1, error || new Error(message));
    };
    return handleCommandFailure;
};
/**
 * Error handling for uncaught errors during CLI command execution.
 *
 * This should be the one and only place where we handle unexpected errors.
 * This includes console logging, debug logging, metrics recording, etc.
 * (Note that we don't do all of those things yet, but this is where they should go)
 */
const handleError = (error, printMessagePreamble, message) => {
    // If yargs threw an error because the customer force-closed a prompt (ie Ctrl+C during a prompt) then the intent to exit the process is clear
    if (isUserForceClosePromptError(error)) {
        return;
    }
    if (error instanceof InvalidCredentialError) {
        printer.print(`${error.message}${EOL}`, COLOR.RED);
        return;
    }
    printMessagePreamble?.();
    printer.print(message || String(error), COLOR.RED);
    if (errorHasCauseMessage(error)) {
        printer.print(error.cause.message, COLOR.RED);
    }
    printer.printNewLine();
};
const isUserForceClosePromptError = (err) => {
    return !!err && err?.message.includes('User force closed the prompt');
};
const errorHasCauseMessage = (error) => {
    return (typeof error?.cause === 'object' &&
        !!error.cause &&
        'message' in error.cause &&
        typeof error.cause.message === 'string');
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JfaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9lcnJvcl9oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNyRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFHekIsSUFBSSw4Q0FBOEMsR0FBRyxLQUFLLENBQUM7QUFFM0Q7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxpQ0FBaUMsR0FBRyxHQUFTLEVBQUU7SUFDMUQsSUFBSSw4Q0FBOEMsRUFBRTtRQUNsRCxPQUFPO0tBQ1I7SUFDRCxPQUFPLENBQUMsRUFBRSxDQUFDLG9CQUFvQixFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDMUMsT0FBTyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDckIsSUFBSSxNQUFNLFlBQVksS0FBSyxFQUFFO1lBQzNCLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNyQjthQUFNLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1lBQ3JDLFdBQVcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO2FBQU07WUFDTCxXQUFXLENBQ1QsSUFBSSxLQUFLLENBQUMsZ0NBQWdDLE9BQU8sTUFBTSxHQUFHLEVBQUU7Z0JBQzFELEtBQUssRUFBRSxNQUFNO2FBQ2QsQ0FBQyxDQUNILENBQUM7U0FDSDtJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO1FBQ3hDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQixDQUFDLENBQUMsQ0FBQztJQUNILDhDQUE4QyxHQUFHLElBQUksQ0FBQztBQUN4RCxDQUFDLENBQUM7QUFFRjs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxDQUFDLE1BQU0sNkJBQTZCLEdBQUcsQ0FDM0MsTUFBWSxFQUMrQixFQUFFO0lBQzdDOzs7O09BSUc7SUFDSCxNQUFNLG9CQUFvQixHQUFHLENBQUMsT0FBZSxFQUFFLEtBQWEsRUFBRSxFQUFFO1FBQzlELE1BQU0sU0FBUyxHQUFHLEdBQUcsRUFBRTtZQUNyQixPQUFPLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDdkIsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN6QixDQUFDLENBQUM7UUFFRixXQUFXLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLElBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUM5QyxDQUFDLENBQUM7SUFDRixPQUFPLG9CQUFvQixDQUFDO0FBQzlCLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNILE1BQU0sV0FBVyxHQUFHLENBQ2xCLEtBQWEsRUFDYixvQkFBaUMsRUFDakMsT0FBZ0IsRUFDaEIsRUFBRTtJQUNGLDhJQUE4STtJQUM5SSxJQUFJLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3RDLE9BQU87S0FDUjtJQUVELElBQUksS0FBSyxZQUFZLHNCQUFzQixFQUFFO1FBQzNDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsRUFBRSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuRCxPQUFPO0tBQ1I7SUFFRCxvQkFBb0IsRUFBRSxFQUFFLENBQUM7SUFDekIsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuRCxJQUFJLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQy9CLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQy9DO0lBQ0QsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ3pCLENBQUMsQ0FBQztBQUVGLE1BQU0sMkJBQTJCLEdBQUcsQ0FBQyxHQUFXLEVBQVcsRUFBRTtJQUMzRCxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsOEJBQThCLENBQUMsQ0FBQztBQUN4RSxDQUFDLENBQUM7QUFFRixNQUFNLG9CQUFvQixHQUFHLENBQzNCLEtBQWEsRUFDb0MsRUFBRTtJQUNuRCxPQUFPLENBQ0wsT0FBTyxLQUFLLEVBQUUsS0FBSyxLQUFLLFFBQVE7UUFDaEMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLO1FBQ2IsU0FBUyxJQUFJLEtBQUssQ0FBQyxLQUFLO1FBQ3hCLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEtBQUssUUFBUSxDQUN4QyxDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ09MT1IgfSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpLWNvcmUnO1xuaW1wb3J0IHsgSW52YWxpZENyZWRlbnRpYWxFcnJvciB9IGZyb20gJy4vZXJyb3IvY3JlZGVudGlhbF9lcnJvci5qcyc7XG5pbXBvcnQgeyBwcmludGVyIH0gZnJvbSAnLi9wcmludGVyLmpzJztcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcbmltcG9ydCB7IEFyZ3YgfSBmcm9tICd5YXJncyc7XG5cbmxldCBoYXNBdHRhY2hVbmhhbmRsZWRFeGNlcHRpb25MaXN0ZW5lcnNCZWVuQ2FsbGVkID0gZmFsc2U7XG5cbi8qKlxuICogQXR0YWNoZXMgcHJvY2VzcyBsaXN0ZW5lcnMgdG8gaGFuZGxlIHVuaGFuZGxlZCBleGNlcHRpb25zIGFuZCByZWplY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBhdHRhY2hVbmhhbmRsZWRFeGNlcHRpb25MaXN0ZW5lcnMgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChoYXNBdHRhY2hVbmhhbmRsZWRFeGNlcHRpb25MaXN0ZW5lcnNCZWVuQ2FsbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIChyZWFzb24pID0+IHtcbiAgICBwcm9jZXNzLmV4aXRDb2RlID0gMTtcbiAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJlYXNvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlRXJyb3IobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVFcnJvcihcbiAgICAgICAgbmV3IEVycm9yKGBVbmhhbmRsZWQgcmVqZWN0aW9uIG9mIHR5cGUgWyR7dHlwZW9mIHJlYXNvbn1dYCwge1xuICAgICAgICAgIGNhdXNlOiByZWFzb24sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCAoZXJyb3IpID0+IHtcbiAgICBwcm9jZXNzLmV4aXRDb2RlID0gMTtcbiAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gIH0pO1xuICBoYXNBdHRhY2hVbmhhbmRsZWRFeGNlcHRpb25MaXN0ZW5lcnNCZWVuQ2FsbGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgY2FsbGJhY2sgdG8geWFyZ3MuZmFpbCgpXG4gKiBBbGwgbG9naWMgZm9yIGFjdHVhbGx5IGhhbmRsaW5nIGVycm9ycyBzaG91bGQgYmUgZGVsZWdhdGVkIHRvIGhhbmRsZUVycm9yLlxuICpcbiAqIEZvciBzb21lIHJlYXNvbiB0aGUgeWFyZ3Mgb2JqZWN0IHRoYXQgaXMgaW5qZWN0ZWQgaW50byB0aGUgZmFpbCBjYWxsYmFjayBkb2VzIG5vdCBpbmNsdWRlIGFsbCBtZXRob2RzIG9uIHRoZSBBcmd2IHR5cGVcbiAqIFRoaXMgZ2VuZXJhdG9yIGFsbG93cyB1cyB0byBpbmplY3QgdGhlIHlhcmdzIHBhcnNlciBpbnRvIHRoZSBjYWxsYmFjayBzbyB0aGF0IHdlIGNhbiBjYWxsIHBhcnNlci5leGl0KCkgZnJvbSB0aGUgZmFpbHVyZSBoYW5kbGVyXG4gKiBUaGlzIHByZXZlbnRzIG91ciB0b3AtbGV2ZWwgZXJyb3IgaGFuZGxlciBmcm9tIGJlaW5nIGludm9rZWQgYWZ0ZXIgdGhlIHlhcmdzIGVycm9yIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiBpbnZva2VkXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUNvbW1hbmRGYWlsdXJlSGFuZGxlciA9IChcbiAgcGFyc2VyOiBBcmd2XG4pOiAoKG1lc3NhZ2U6IHN0cmluZywgZXJyb3I6IEVycm9yKSA9PiB2b2lkKSA9PiB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3Igb3V0cHV0IHdoZW4gYSBjb21tYW5kIGZhaWxzXG4gICAqIEBwYXJhbSBtZXNzYWdlIGVycm9yIG1lc3NhZ2Ugc2V0IGJ5IHRoZSB5YXJnczpjaGVjayB2YWxpZGF0aW9uc1xuICAgKiBAcGFyYW0gZXJyb3IgZXJyb3IgdGhyb3duIGJ5IHlhcmdzIGhhbmRsZXJcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNvbW1hbmRGYWlsdXJlID0gKG1lc3NhZ2U6IHN0cmluZywgZXJyb3I/OiBFcnJvcikgPT4ge1xuICAgIGNvbnN0IHByaW50SGVscCA9ICgpID0+IHtcbiAgICAgIHByaW50ZXIucHJpbnROZXdMaW5lKCk7XG4gICAgICBwYXJzZXIuc2hvd0hlbHAoKTtcbiAgICAgIHByaW50ZXIucHJpbnROZXdMaW5lKCk7XG4gICAgfTtcblxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBwcmludEhlbHAsIG1lc3NhZ2UpO1xuICAgIHBhcnNlci5leGl0KDEsIGVycm9yIHx8IG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gIH07XG4gIHJldHVybiBoYW5kbGVDb21tYW5kRmFpbHVyZTtcbn07XG5cbi8qKlxuICogRXJyb3IgaGFuZGxpbmcgZm9yIHVuY2F1Z2h0IGVycm9ycyBkdXJpbmcgQ0xJIGNvbW1hbmQgZXhlY3V0aW9uLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHRoZSBvbmUgYW5kIG9ubHkgcGxhY2Ugd2hlcmUgd2UgaGFuZGxlIHVuZXhwZWN0ZWQgZXJyb3JzLlxuICogVGhpcyBpbmNsdWRlcyBjb25zb2xlIGxvZ2dpbmcsIGRlYnVnIGxvZ2dpbmcsIG1ldHJpY3MgcmVjb3JkaW5nLCBldGMuXG4gKiAoTm90ZSB0aGF0IHdlIGRvbid0IGRvIGFsbCBvZiB0aG9zZSB0aGluZ3MgeWV0LCBidXQgdGhpcyBpcyB3aGVyZSB0aGV5IHNob3VsZCBnbylcbiAqL1xuY29uc3QgaGFuZGxlRXJyb3IgPSAoXG4gIGVycm9yPzogRXJyb3IsXG4gIHByaW50TWVzc2FnZVByZWFtYmxlPzogKCkgPT4gdm9pZCxcbiAgbWVzc2FnZT86IHN0cmluZ1xuKSA9PiB7XG4gIC8vIElmIHlhcmdzIHRocmV3IGFuIGVycm9yIGJlY2F1c2UgdGhlIGN1c3RvbWVyIGZvcmNlLWNsb3NlZCBhIHByb21wdCAoaWUgQ3RybCtDIGR1cmluZyBhIHByb21wdCkgdGhlbiB0aGUgaW50ZW50IHRvIGV4aXQgdGhlIHByb2Nlc3MgaXMgY2xlYXJcbiAgaWYgKGlzVXNlckZvcmNlQ2xvc2VQcm9tcHRFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJbnZhbGlkQ3JlZGVudGlhbEVycm9yKSB7XG4gICAgcHJpbnRlci5wcmludChgJHtlcnJvci5tZXNzYWdlfSR7RU9MfWAsIENPTE9SLlJFRCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJpbnRNZXNzYWdlUHJlYW1ibGU/LigpO1xuICBwcmludGVyLnByaW50KG1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKSwgQ09MT1IuUkVEKTtcbiAgaWYgKGVycm9ySGFzQ2F1c2VNZXNzYWdlKGVycm9yKSkge1xuICAgIHByaW50ZXIucHJpbnQoZXJyb3IuY2F1c2UubWVzc2FnZSwgQ09MT1IuUkVEKTtcbiAgfVxuICBwcmludGVyLnByaW50TmV3TGluZSgpO1xufTtcblxuY29uc3QgaXNVc2VyRm9yY2VDbG9zZVByb21wdEVycm9yID0gKGVycj86IEVycm9yKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAhIWVyciAmJiBlcnI/Lm1lc3NhZ2UuaW5jbHVkZXMoJ1VzZXIgZm9yY2UgY2xvc2VkIHRoZSBwcm9tcHQnKTtcbn07XG5cbmNvbnN0IGVycm9ySGFzQ2F1c2VNZXNzYWdlID0gKFxuICBlcnJvcj86IEVycm9yXG4pOiBlcnJvciBpcyBFcnJvciAmIHsgY2F1c2U6IHsgbWVzc2FnZTogc3RyaW5nIH0gfSA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGVycm9yPy5jYXVzZSA9PT0gJ29iamVjdCcgJiZcbiAgICAhIWVycm9yLmNhdXNlICYmXG4gICAgJ21lc3NhZ2UnIGluIGVycm9yLmNhdXNlICYmXG4gICAgdHlwZW9mIGVycm9yLmNhdXNlLm1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICk7XG59O1xuIl19