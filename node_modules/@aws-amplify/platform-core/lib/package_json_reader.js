"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packageJsonSchema = exports.PackageJsonReader = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const zod_1 = __importDefault(require("zod"));
const errors_1 = require("./errors");
/**
 * return the package json
 */
class PackageJsonReader {
    read = (absolutePackageJsonPath) => {
        if (!fs_1.default.existsSync(absolutePackageJsonPath)) {
            throw new Error(`Could not find a package.json file at ${absolutePackageJsonPath}`);
        }
        let jsonParsedValue;
        try {
            jsonParsedValue = JSON.parse(
            // we have to use sync fs methods here because this is also used during cdk synth
            fs_1.default.readFileSync(absolutePackageJsonPath, 'utf-8'));
        }
        catch (err) {
            throw new errors_1.AmplifyUserError('InvalidPackageJsonError', {
                message: `Could not parse the contents of ${absolutePackageJsonPath}`,
                resolution: `Ensure that ${absolutePackageJsonPath} exists and is a valid JSON file`,
            }, err);
        }
        return exports.packageJsonSchema.parse(jsonParsedValue);
    };
    /**
     * Returns the contents of the package.json file in process.cwd()
     *
     * If no package.json file exists, or the content does not pass validation, an error is thrown
     */
    readFromCwd = () => {
        return this.read(path_1.default.resolve(process.cwd(), 'package.json'));
    };
}
exports.PackageJsonReader = PackageJsonReader;
/**
 * Type for package.json content.
 *
 * Add additional validation if there are other fields we need to read
 */
exports.packageJsonSchema = zod_1.default.object({
    name: zod_1.default.string().optional(),
    version: zod_1.default.string().optional(),
    type: zod_1.default.union([zod_1.default.literal('module'), zod_1.default.literal('commonjs')]).optional(),
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZV9qc29uX3JlYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wYWNrYWdlX2pzb25fcmVhZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDRDQUFvQjtBQUNwQixnREFBd0I7QUFDeEIsOENBQW9CO0FBQ3BCLHFDQUE0QztBQUU1Qzs7R0FFRztBQUNILE1BQWEsaUJBQWlCO0lBQzVCLElBQUksR0FBRyxDQUFDLHVCQUErQixFQUFlLEVBQUU7UUFDdEQsSUFBSSxDQUFDLFlBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTtZQUMzQyxNQUFNLElBQUksS0FBSyxDQUNiLHlDQUF5Qyx1QkFBdUIsRUFBRSxDQUNuRSxDQUFDO1NBQ0g7UUFDRCxJQUFJLGVBQXdDLENBQUM7UUFDN0MsSUFBSTtZQUNGLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSztZQUMxQixpRkFBaUY7WUFDakYsWUFBRSxDQUFDLFlBQVksQ0FBQyx1QkFBdUIsRUFBRSxPQUFPLENBQUMsQ0FDbEQsQ0FBQztTQUNIO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixNQUFNLElBQUkseUJBQWdCLENBQ3hCLHlCQUF5QixFQUN6QjtnQkFDRSxPQUFPLEVBQUUsbUNBQW1DLHVCQUF1QixFQUFFO2dCQUNyRSxVQUFVLEVBQUUsZUFBZSx1QkFBdUIsa0NBQWtDO2FBQ3JGLEVBQ0QsR0FBWSxDQUNiLENBQUM7U0FDSDtRQUNELE9BQU8seUJBQWlCLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ2xELENBQUMsQ0FBQztJQUVGOzs7O09BSUc7SUFDSCxXQUFXLEdBQUcsR0FBZ0IsRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDLENBQUM7Q0FDSDtBQWxDRCw4Q0FrQ0M7QUFFRDs7OztHQUlHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRyxhQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3hDLElBQUksRUFBRSxhQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQzNCLE9BQU8sRUFBRSxhQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQzlCLElBQUksRUFBRSxhQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxhQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7Q0FDdkUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHogZnJvbSAnem9kJztcbmltcG9ydCB7IEFtcGxpZnlVc2VyRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogcmV0dXJuIHRoZSBwYWNrYWdlIGpzb25cbiAqL1xuZXhwb3J0IGNsYXNzIFBhY2thZ2VKc29uUmVhZGVyIHtcbiAgcmVhZCA9IChhYnNvbHV0ZVBhY2thZ2VKc29uUGF0aDogc3RyaW5nKTogUGFja2FnZUpzb24gPT4ge1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhhYnNvbHV0ZVBhY2thZ2VKc29uUGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIGEgcGFja2FnZS5qc29uIGZpbGUgYXQgJHthYnNvbHV0ZVBhY2thZ2VKc29uUGF0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQganNvblBhcnNlZFZhbHVlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB0cnkge1xuICAgICAganNvblBhcnNlZFZhbHVlID0gSlNPTi5wYXJzZShcbiAgICAgICAgLy8gd2UgaGF2ZSB0byB1c2Ugc3luYyBmcyBtZXRob2RzIGhlcmUgYmVjYXVzZSB0aGlzIGlzIGFsc28gdXNlZCBkdXJpbmcgY2RrIHN5bnRoXG4gICAgICAgIGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZVBhY2thZ2VKc29uUGF0aCwgJ3V0Zi04JylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcihcbiAgICAgICAgJ0ludmFsaWRQYWNrYWdlSnNvbkVycm9yJyxcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgcGFyc2UgdGhlIGNvbnRlbnRzIG9mICR7YWJzb2x1dGVQYWNrYWdlSnNvblBhdGh9YCxcbiAgICAgICAgICByZXNvbHV0aW9uOiBgRW5zdXJlIHRoYXQgJHthYnNvbHV0ZVBhY2thZ2VKc29uUGF0aH0gZXhpc3RzIGFuZCBpcyBhIHZhbGlkIEpTT04gZmlsZWAsXG4gICAgICAgIH0sXG4gICAgICAgIGVyciBhcyBFcnJvclxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhY2thZ2VKc29uU2NoZW1hLnBhcnNlKGpzb25QYXJzZWRWYWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBwYWNrYWdlLmpzb24gZmlsZSBpbiBwcm9jZXNzLmN3ZCgpXG4gICAqXG4gICAqIElmIG5vIHBhY2thZ2UuanNvbiBmaWxlIGV4aXN0cywgb3IgdGhlIGNvbnRlbnQgZG9lcyBub3QgcGFzcyB2YWxpZGF0aW9uLCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICovXG4gIHJlYWRGcm9tQ3dkID0gKCk6IFBhY2thZ2VKc29uID0+IHtcbiAgICByZXR1cm4gdGhpcy5yZWFkKHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAncGFja2FnZS5qc29uJykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR5cGUgZm9yIHBhY2thZ2UuanNvbiBjb250ZW50LlxuICpcbiAqIEFkZCBhZGRpdGlvbmFsIHZhbGlkYXRpb24gaWYgdGhlcmUgYXJlIG90aGVyIGZpZWxkcyB3ZSBuZWVkIHRvIHJlYWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhY2thZ2VKc29uU2NoZW1hID0gei5vYmplY3Qoe1xuICBuYW1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHZlcnNpb246IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdHlwZTogei51bmlvbihbei5saXRlcmFsKCdtb2R1bGUnKSwgei5saXRlcmFsKCdjb21tb25qcycpXSkub3B0aW9uYWwoKSxcbn0pO1xuXG5leHBvcnQgdHlwZSBQYWNrYWdlSnNvbiA9IHouaW5mZXI8dHlwZW9mIHBhY2thZ2VKc29uU2NoZW1hPjtcbiJdfQ==