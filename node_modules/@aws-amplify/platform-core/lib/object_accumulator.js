"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectAccumulator = exports.ObjectAccumulatorPropertyAlreadyExistsError = void 0;
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
/**
 * This error is thrown when there's a collision in
 */
class ObjectAccumulatorPropertyAlreadyExistsError extends Error {
    key;
    existingValue;
    incomingValue;
    /**
     * Creates property already exists error.
     */
    constructor(key, existingValue, incomingValue) {
        super(`Property ${key} already exists`);
        this.key = key;
        this.existingValue = existingValue;
        this.incomingValue = incomingValue;
    }
}
exports.ObjectAccumulatorPropertyAlreadyExistsError = ObjectAccumulatorPropertyAlreadyExistsError;
/**
 * A class that can accumulate (squash merge) objects into single instance.
 */
class ObjectAccumulator {
    accumulator;
    /**
     * creates object accumulator.
     */
    constructor(accumulator) {
        this.accumulator = accumulator;
    }
    accumulate = (part) => {
        (0, lodash_mergewith_1.default)(this.accumulator, part, (existingValue, incomingValue, key) => {
            if (Array.isArray(existingValue)) {
                return existingValue.concat(incomingValue);
            }
            if (existingValue && typeof existingValue !== 'object') {
                throw new ObjectAccumulatorPropertyAlreadyExistsError(key, existingValue, incomingValue);
            }
            // returning undefined falls back to default merge algorithm
            return undefined;
        });
        return this;
    };
    getAccumulatedObject = () => {
        return this.accumulator;
    };
}
exports.ObjectAccumulator = ObjectAccumulator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0X2FjY3VtdWxhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL29iamVjdF9hY2N1bXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx3RUFBeUM7QUFFekM7O0dBRUc7QUFDSCxNQUFhLDJDQUE0QyxTQUFRLEtBQUs7SUFLekQ7SUFDQTtJQUNBO0lBTlg7O09BRUc7SUFDSCxZQUNXLEdBQVcsRUFDWCxhQUFzQixFQUN0QixhQUFzQjtRQUUvQixLQUFLLENBQUMsWUFBWSxHQUFHLGlCQUFpQixDQUFDLENBQUM7UUFKL0IsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUNYLGtCQUFhLEdBQWIsYUFBYSxDQUFTO1FBQ3RCLGtCQUFhLEdBQWIsYUFBYSxDQUFTO0lBR2pDLENBQUM7Q0FDRjtBQVhELGtHQVdDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGlCQUFpQjtJQUlDO0lBSDdCOztPQUVHO0lBQ0gsWUFBNkIsV0FBdUI7UUFBdkIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7SUFBRyxDQUFDO0lBRXhELFVBQVUsR0FBRyxDQUFDLElBQWdCLEVBQXdCLEVBQUU7UUFDdEQsSUFBQSwwQkFBUyxFQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUN0RSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sYUFBYSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQzthQUM1QztZQUNELElBQUksYUFBYSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRTtnQkFDdEQsTUFBTSxJQUFJLDJDQUEyQyxDQUNuRCxHQUFHLEVBQ0gsYUFBYSxFQUNiLGFBQWEsQ0FDZCxDQUFDO2FBQ0g7WUFDRCw0REFBNEQ7WUFDNUQsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUMsQ0FBQztJQUVGLG9CQUFvQixHQUFHLEdBQUcsRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQyxDQUFDO0NBQ0g7QUEzQkQsOENBMkJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1lcmdlV2l0aCBmcm9tICdsb2Rhc2gubWVyZ2V3aXRoJztcblxuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIHRoZXJlJ3MgYSBjb2xsaXNpb24gaW5cbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEFjY3VtdWxhdG9yUHJvcGVydHlBbHJlYWR5RXhpc3RzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIHByb3BlcnR5IGFscmVhZHkgZXhpc3RzIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgZXhpc3RpbmdWYWx1ZTogdW5rbm93bixcbiAgICByZWFkb25seSBpbmNvbWluZ1ZhbHVlOiB1bmtub3duXG4gICkge1xuICAgIHN1cGVyKGBQcm9wZXJ0eSAke2tleX0gYWxyZWFkeSBleGlzdHNgKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYWNjdW11bGF0ZSAoc3F1YXNoIG1lcmdlKSBvYmplY3RzIGludG8gc2luZ2xlIGluc3RhbmNlLlxuICovXG5leHBvcnQgY2xhc3MgT2JqZWN0QWNjdW11bGF0b3I8VD4ge1xuICAvKipcbiAgICogY3JlYXRlcyBvYmplY3QgYWNjdW11bGF0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGFjY3VtdWxhdG9yOiBQYXJ0aWFsPFQ+KSB7fVxuXG4gIGFjY3VtdWxhdGUgPSAocGFydDogUGFydGlhbDxUPik6IE9iamVjdEFjY3VtdWxhdG9yPFQ+ID0+IHtcbiAgICBtZXJnZVdpdGgodGhpcy5hY2N1bXVsYXRvciwgcGFydCwgKGV4aXN0aW5nVmFsdWUsIGluY29taW5nVmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWUuY29uY2F0KGluY29taW5nVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgJiYgdHlwZW9mIGV4aXN0aW5nVmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBPYmplY3RBY2N1bXVsYXRvclByb3BlcnR5QWxyZWFkeUV4aXN0c0Vycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBleGlzdGluZ1ZhbHVlLFxuICAgICAgICAgIGluY29taW5nVmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybmluZyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0IG1lcmdlIGFsZ29yaXRobVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBnZXRBY2N1bXVsYXRlZE9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5hY2N1bXVsYXRvcjtcbiAgfTtcbn1cbiJdfQ==