"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmplifyError = void 0;
const _1 = require(".");
/**
 * Base class for all Amplify errors or faults
 */
class AmplifyError extends Error {
    name;
    classification;
    options;
    cause;
    serializedError;
    message;
    resolution;
    details;
    link;
    code;
    /**
     * You should use AmplifyUserError or AmplifyLibraryFault to throw an error.
     * @param name - a user friendly name for the exception
     * @param classification - LibraryFault or UserError
     * @param options - error stack, resolution steps, details, or help links
     * @param cause If you are throwing this exception from within a catch block,
     * you must provide the exception that was caught.
     * @example
     * try {
     *  ...
     * } catch (error){
     *    throw new AmplifyError(...,...,error);
     * }
     */
    constructor(name, classification, options, cause) {
        // If an AmplifyError was already thrown, we must allow it to reach the user.
        // This ensures that resolution steps, and the original error are bubbled up.
        super(options.message, { cause });
        this.name = name;
        this.classification = classification;
        this.options = options;
        this.cause = cause;
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, AmplifyError.prototype);
        this.message = options.message;
        this.details = options.details;
        this.resolution = options.resolution;
        this.code = options.code;
        this.link = options.link;
        if (cause && cause instanceof AmplifyError) {
            cause.serializedError = undefined;
        }
        this.serializedError = JSON.stringify({
            name,
            classification,
            options,
            cause,
        });
    }
    static fromStderr = (_stderr) => {
        const extractionRegex = /["']?serializedError["']?:[ ]?["'](.*)["']/;
        const serialized = _stderr.match(extractionRegex);
        if (serialized && serialized.length == 2) {
            try {
                const { name, classification, options, cause } = JSON.parse(serialized[1]);
                return classification === 'ERROR'
                    ? new _1.AmplifyUserError(name, options, cause)
                    : new _1.AmplifyFault(name, options, cause);
            }
            catch (error) {
                // cannot deserialize
                return undefined;
            }
        }
        return undefined;
    };
    static fromError = (error) => {
        const errorMessage = error instanceof Error
            ? `${error.name}: ${error.message}`
            : 'An unknown error happened. Check downstream error';
        return new _1.AmplifyFault('UnknownFault', {
            message: errorMessage,
        }, error instanceof Error ? error : new Error(String(error)));
    };
}
exports.AmplifyError = AmplifyError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1wbGlmeV9lcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMvYW1wbGlmeV9lcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3QkFBbUQ7QUFFbkQ7O0dBRUc7QUFDSCxNQUFzQixZQUFhLFNBQVEsS0FBSztJQXVCNUI7SUFDQTtJQUNDO0lBQ0Q7SUF6QlgsZUFBZSxDQUFVO0lBQ2hCLE9BQU8sQ0FBUztJQUNoQixVQUFVLENBQVU7SUFDcEIsT0FBTyxDQUFVO0lBQ2pCLElBQUksQ0FBVTtJQUNkLElBQUksQ0FBVTtJQUU5Qjs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFDa0IsSUFBc0IsRUFDdEIsY0FBMEMsRUFDekMsT0FBNEIsRUFDN0IsS0FBYTtRQUU3Qiw2RUFBNkU7UUFDN0UsNkVBQTZFO1FBQzdFLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQVBsQixTQUFJLEdBQUosSUFBSSxDQUFrQjtRQUN0QixtQkFBYyxHQUFkLGNBQWMsQ0FBNEI7UUFDekMsWUFBTyxHQUFQLE9BQU8sQ0FBcUI7UUFDN0IsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQU03Qiw2SUFBNkk7UUFDN0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDL0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFFekIsSUFBSSxLQUFLLElBQUksS0FBSyxZQUFZLFlBQVksRUFBRTtZQUMxQyxLQUFLLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQztTQUNuQztRQUNELElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNwQyxJQUFJO1lBQ0osY0FBYztZQUNkLE9BQU87WUFDUCxLQUFLO1NBQ04sQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxPQUFlLEVBQTRCLEVBQUU7UUFDaEUsTUFBTSxlQUFlLEdBQUcsNENBQTRDLENBQUM7UUFDckUsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNsRCxJQUFJLFVBQVUsSUFBSSxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUN4QyxJQUFJO2dCQUNGLE1BQU0sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUN6RCxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQ2QsQ0FBQztnQkFDRixPQUFPLGNBQWMsS0FBSyxPQUFPO29CQUMvQixDQUFDLENBQUMsSUFBSSxtQkFBZ0IsQ0FBQyxJQUE0QixFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUM7b0JBQ3BFLENBQUMsQ0FBQyxJQUFJLGVBQVksQ0FBQyxJQUErQixFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN2RTtZQUFDLE9BQU8sS0FBSyxFQUFFO2dCQUNkLHFCQUFxQjtnQkFDckIsT0FBTyxTQUFTLENBQUM7YUFDbEI7U0FDRjtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUMsQ0FBQztJQUVGLE1BQU0sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxLQUFjLEVBQWdCLEVBQUU7UUFDbEQsTUFBTSxZQUFZLEdBQ2hCLEtBQUssWUFBWSxLQUFLO1lBQ3BCLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLE9BQU8sRUFBRTtZQUNuQyxDQUFDLENBQUMsbURBQW1ELENBQUM7UUFFMUQsT0FBTyxJQUFJLGVBQVksQ0FDckIsY0FBYyxFQUNkO1lBQ0UsT0FBTyxFQUFFLFlBQVk7U0FDdEIsRUFDRCxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUMxRCxDQUFDO0lBQ0osQ0FBQyxDQUFDOztBQXBGSixvQ0FxRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbXBsaWZ5RmF1bHQsIEFtcGxpZnlVc2VyRXJyb3IgfSBmcm9tICcuJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgQW1wbGlmeSBlcnJvcnMgb3IgZmF1bHRzXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBbXBsaWZ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyBzZXJpYWxpemVkRXJyb3I/OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBtZXNzYWdlOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSByZXNvbHV0aW9uPzogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgZGV0YWlscz86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGxpbms/OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBjb2RlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBZb3Ugc2hvdWxkIHVzZSBBbXBsaWZ5VXNlckVycm9yIG9yIEFtcGxpZnlMaWJyYXJ5RmF1bHQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAqIEBwYXJhbSBuYW1lIC0gYSB1c2VyIGZyaWVuZGx5IG5hbWUgZm9yIHRoZSBleGNlcHRpb25cbiAgICogQHBhcmFtIGNsYXNzaWZpY2F0aW9uIC0gTGlicmFyeUZhdWx0IG9yIFVzZXJFcnJvclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGVycm9yIHN0YWNrLCByZXNvbHV0aW9uIHN0ZXBzLCBkZXRhaWxzLCBvciBoZWxwIGxpbmtzXG4gICAqIEBwYXJhbSBjYXVzZSBJZiB5b3UgYXJlIHRocm93aW5nIHRoaXMgZXhjZXB0aW9uIGZyb20gd2l0aGluIGEgY2F0Y2ggYmxvY2ssXG4gICAqIHlvdSBtdXN0IHByb3ZpZGUgdGhlIGV4Y2VwdGlvbiB0aGF0IHdhcyBjYXVnaHQuXG4gICAqIEBleGFtcGxlXG4gICAqIHRyeSB7XG4gICAqICAuLi5cbiAgICogfSBjYXRjaCAoZXJyb3Ipe1xuICAgKiAgICB0aHJvdyBuZXcgQW1wbGlmeUVycm9yKC4uLiwuLi4sZXJyb3IpO1xuICAgKiB9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogQW1wbGlmeUVycm9yVHlwZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2xhc3NpZmljYXRpb246IEFtcGxpZnlFcnJvckNsYXNzaWZpY2F0aW9uLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogQW1wbGlmeUVycm9yT3B0aW9ucyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICAvLyBJZiBhbiBBbXBsaWZ5RXJyb3Igd2FzIGFscmVhZHkgdGhyb3duLCB3ZSBtdXN0IGFsbG93IGl0IHRvIHJlYWNoIHRoZSB1c2VyLlxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHJlc29sdXRpb24gc3RlcHMsIGFuZCB0aGUgb3JpZ2luYWwgZXJyb3IgYXJlIGJ1YmJsZWQgdXAuXG4gICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlLCB7IGNhdXNlIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYWluL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFtcGxpZnlFcnJvci5wcm90b3R5cGUpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZGV0YWlscyA9IG9wdGlvbnMuZGV0YWlscztcbiAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgdGhpcy5jb2RlID0gb3B0aW9ucy5jb2RlO1xuICAgIHRoaXMubGluayA9IG9wdGlvbnMubGluaztcblxuICAgIGlmIChjYXVzZSAmJiBjYXVzZSBpbnN0YW5jZW9mIEFtcGxpZnlFcnJvcikge1xuICAgICAgY2F1c2Uuc2VyaWFsaXplZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLnNlcmlhbGl6ZWRFcnJvciA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG5hbWUsXG4gICAgICBjbGFzc2lmaWNhdGlvbixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjYXVzZSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RkZXJyID0gKF9zdGRlcnI6IHN0cmluZyk6IEFtcGxpZnlFcnJvciB8IHVuZGVmaW5lZCA9PiB7XG4gICAgY29uc3QgZXh0cmFjdGlvblJlZ2V4ID0gL1tcIiddP3NlcmlhbGl6ZWRFcnJvcltcIiddPzpbIF0/W1wiJ10oLiopW1wiJ10vO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBfc3RkZXJyLm1hdGNoKGV4dHJhY3Rpb25SZWdleCk7XG4gICAgaWYgKHNlcmlhbGl6ZWQgJiYgc2VyaWFsaXplZC5sZW5ndGggPT0gMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBjbGFzc2lmaWNhdGlvbiwgb3B0aW9ucywgY2F1c2UgfSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgc2VyaWFsaXplZFsxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY2xhc3NpZmljYXRpb24gPT09ICdFUlJPUidcbiAgICAgICAgICA/IG5ldyBBbXBsaWZ5VXNlckVycm9yKG5hbWUgYXMgQW1wbGlmeVVzZXJFcnJvclR5cGUsIG9wdGlvbnMsIGNhdXNlKVxuICAgICAgICAgIDogbmV3IEFtcGxpZnlGYXVsdChuYW1lIGFzIEFtcGxpZnlMaWJyYXJ5RmF1bHRUeXBlLCBvcHRpb25zLCBjYXVzZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBjYW5ub3QgZGVzZXJpYWxpemVcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBzdGF0aWMgZnJvbUVycm9yID0gKGVycm9yOiB1bmtub3duKTogQW1wbGlmeUVycm9yID0+IHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/IGAke2Vycm9yLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICA6ICdBbiB1bmtub3duIGVycm9yIGhhcHBlbmVkLiBDaGVjayBkb3duc3RyZWFtIGVycm9yJztcblxuICAgIHJldHVybiBuZXcgQW1wbGlmeUZhdWx0KFxuICAgICAgJ1Vua25vd25GYXVsdCcsXG4gICAgICB7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0sXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEFtcGxpZnkgZXhjZXB0aW9uIGNsYXNzaWZpY2F0aW9uc1xuICovXG5leHBvcnQgdHlwZSBBbXBsaWZ5RXJyb3JDbGFzc2lmaWNhdGlvbiA9ICdGQVVMVCcgfCAnRVJST1InO1xuXG4vKipcbiAqIEFtcGxpZnkgRXJyb3Igb3B0aW9ucyBvYmplY3RcbiAqL1xuZXhwb3J0IHR5cGUgQW1wbGlmeUVycm9yT3B0aW9ucyA9IHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkZXRhaWxzPzogc3RyaW5nO1xuICByZXNvbHV0aW9uPzogc3RyaW5nO1xuICBsaW5rPzogc3RyaW5nO1xuXG4gIC8vIENsb3VkRm9ybWF0aW9uIG9yIE5vZGVKUyBlcnJvciBjb2Rlc1xuICBjb2RlPzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBbXBsaWZ5IGVycm9yIHR5cGVzXG4gKi9cbmV4cG9ydCB0eXBlIEFtcGxpZnlFcnJvclR5cGUgPSBBbXBsaWZ5VXNlckVycm9yVHlwZSB8IEFtcGxpZnlMaWJyYXJ5RmF1bHRUeXBlO1xuXG4vKipcbiAqIEFtcGxpZnkgZXJyb3IgdHlwZXNcbiAqL1xuZXhwb3J0IHR5cGUgQW1wbGlmeVVzZXJFcnJvclR5cGUgPVxuICB8ICdJbnZhbGlkUGFja2FnZUpzb25FcnJvcidcbiAgfCAnSW52YWxpZFNjaGVtYUF1dGhFcnJvcidcbiAgfCAnSW52YWxpZFNjaGVtYUVycm9yJ1xuICB8ICdFeHBpcmVkVG9rZW5FcnJvcidcbiAgfCAnQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50RXJyb3InXG4gIHwgJ0NGTlVwZGF0ZU5vdFN1cHBvcnRlZEVycm9yJ1xuICB8ICdTeW50YXhFcnJvcidcbiAgfCAnQmFja2VuZEJ1aWxkRXJyb3InXG4gIHwgJ0Jvb3RzdHJhcE5vdERldGVjdGVkRXJyb3InXG4gIHwgJ0FjY2Vzc0RlbmllZEVycm9yJ1xuICB8ICdGaWxlQ29udmVudGlvbkVycm9yJ1xuICB8ICdPdXRwdXRFbnRyeUFscmVhZHlFeGlzdHNFcnJvcidcbiAgfCAnSW52YWxpZFJlc291cmNlTmFtZUVycm9yJztcblxuLyoqXG4gKiBBbXBsaWZ5IGxpYnJhcnkgZmF1bHQgdHlwZXNcbiAqL1xuZXhwb3J0IHR5cGUgQW1wbGlmeUxpYnJhcnlGYXVsdFR5cGUgPSAnVW5rbm93bkZhdWx0JztcbiJdfQ==