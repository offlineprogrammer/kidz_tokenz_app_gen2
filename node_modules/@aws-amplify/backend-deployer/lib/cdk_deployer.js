import stream from 'stream';
import readline from 'readline';
import { AmplifyUserError, CDKContextKey, } from '@aws-amplify/platform-core';
import { dirname } from 'path';
/**
 * Commands that can be invoked
 */
var InvokableCommand;
(function (InvokableCommand) {
    InvokableCommand["DEPLOY"] = "deploy";
    InvokableCommand["DESTROY"] = "destroy";
})(InvokableCommand || (InvokableCommand = {}));
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
    }
    /**
     * Invokes cdk deploy command
     */
    deploy = async (backendId, deployProps) => {
        await this.invokeTsc(deployProps);
        const cdkCommandArgs = [];
        if (backendId.type === 'sandbox') {
            cdkCommandArgs.push('--hotswap-fallback');
            cdkCommandArgs.push('--method=direct');
            if (deployProps?.secretLastUpdated) {
                cdkCommandArgs.push('--context', `secretLastUpdated=${deployProps.secretLastUpdated.getTime()}`);
            }
        }
        return this.tryInvokeCdk(InvokableCommand.DEPLOY, backendId, cdkCommandArgs);
    };
    /**
     * Invokes cdk destroy command
     */
    destroy = async (backendId) => {
        return this.tryInvokeCdk(InvokableCommand.DESTROY, backendId, ['--force']);
    };
    /**
     * Wrapper for the child process executor. Helps in unit testing as node:test framework
     * doesn't have capabilities to mock exported functions like `execa` as of right now.
     */
    executeCommand = async (commandArgs, options = { printStdout: true }) => {
        // We let the stdout and stdin inherit and streamed to parent process but pipe
        // the stderr and use it to throw on failure. This is to prevent actual
        // actionable errors being hidden among the stdout. Moreover execa errors are
        // useless when calling CLIs unless you made execa calling error.
        let aggregatedStderr = '';
        const aggregatorStderrStream = new stream.Writable();
        aggregatorStderrStream._write = function (chunk, encoding, done) {
            aggregatedStderr += chunk;
            done();
        };
        const childProcess = this.packageManagerController.runWithPackageManager(commandArgs, process.cwd(), {
            stdin: 'inherit',
            stdout: 'pipe',
            stderr: 'pipe',
            // Piping the output by default strips off the color. This is a workaround to
            // preserve the color being piped to parent process.
            extendEnv: true,
            env: { FORCE_COLOR: '1' },
        });
        childProcess.stderr?.pipe(aggregatorStderrStream);
        if (options?.printStdout) {
            childProcess.stdout?.pipe(process.stdout);
        }
        const cdkOutput = { deploymentTimes: {} };
        if (childProcess.stdout) {
            await this.populateCDKOutputFromStdout(cdkOutput, childProcess.stdout);
        }
        try {
            await childProcess;
            return cdkOutput;
        }
        catch (error) {
            // swallow execa error which is most of the time noise (basically child exited with exit code...)
            // bubbling this up to customers add confusion (Customers don't need to know we are running IPC calls
            // and their exit codes printed while sandbox continue to run). Hence we explicitly don't pass error in the cause
            // rather throw the entire stderr for clients to figure out what to do with it.
            throw new Error(aggregatedStderr);
        }
    };
    invokeTsc = async (deployProps) => {
        if (!deployProps?.validateAppSources) {
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--showConfig',
                '--project',
                dirname(this.backendLocator.locate()),
            ], { printStdout: false });
        }
        catch (error) {
            // If we cannot load ts config, turn off type checking
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--noEmit',
                '--skipLibCheck',
                // pointing the project arg to the amplify backend directory will use the tsconfig present in that directory
                '--project',
                dirname(this.backendLocator.locate()),
            ]);
        }
        catch (err) {
            throw new AmplifyUserError('SyntaxError', {
                message: 'TypeScript validation check failed, check your backend definition',
            }, err instanceof Error ? err : undefined);
        }
    };
    /**
     * calls invokeCDK and wrap it in a try catch
     */
    tryInvokeCdk = async (invokableCommand, backendId, additionalArguments) => {
        try {
            return await this.invokeCdk(invokableCommand, backendId, additionalArguments);
        }
        catch (err) {
            throw this.cdkErrorMapper.getAmplifyError(err);
        }
    };
    /**
     * Executes a CDK command
     */
    invokeCdk = async (invokableCommand, backendId, additionalArguments) => {
        // Basic args
        const cdkCommandArgs = [
            'cdk',
            invokableCommand.toString(),
            // This is unfortunate. CDK writes everything to stderr without `--ci` flag and we need to differentiate between the two.
            // See https://github.com/aws/aws-cdk/issues/7717 for more details.
            '--ci',
            '--app',
            this.packageManagerController.getCommand([
                'tsx',
                this.backendLocator.locate(),
            ]),
            '--all',
            '--output',
            '.amplify/artifacts/cdk.out',
        ];
        // Add context information if available
        cdkCommandArgs.push('--context', `${CDKContextKey.BACKEND_NAMESPACE}=${backendId.namespace}`, '--context', `${CDKContextKey.BACKEND_NAME}=${backendId.name}`);
        if (backendId.type !== 'sandbox') {
            cdkCommandArgs.push('--require-approval', 'never');
        }
        cdkCommandArgs.push('--context', `${CDKContextKey.DEPLOYMENT_TYPE}=${backendId.type}`);
        if (additionalArguments) {
            cdkCommandArgs.push(...additionalArguments);
        }
        return await this.executeCommand(cdkCommandArgs);
    };
    populateCDKOutputFromStdout = async (output, stdout) => {
        const regexTotalTime = /✨ {2}Total time: (\d*\.*\d*)s.*/;
        const regexSynthTime = /✨ {2}Synthesis time: (\d*\.*\d*)s/;
        const reader = readline.createInterface(stdout);
        for await (const line of reader) {
            if (line.includes('✨')) {
                // Good chance that it contains timing information
                const totalTime = line.match(regexTotalTime);
                if (totalTime && totalTime.length > 1 && !isNaN(+totalTime[1])) {
                    output.deploymentTimes.totalTime = +totalTime[1];
                }
                const synthTime = line.match(regexSynthTime);
                if (synthTime && synthTime.length > 1 && !isNaN(+synthTime[1])) {
                    output.deploymentTimes.synthesisTime = +synthTime[1];
                }
            }
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxRQUFRLE1BQU0sVUFBVSxDQUFDO0FBWWhDLE9BQU8sRUFDTCxnQkFBZ0IsRUFFaEIsYUFBYSxHQUNkLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQjs7R0FFRztBQUNILElBQUssZ0JBR0o7QUFIRCxXQUFLLGdCQUFnQjtJQUNuQixxQ0FBaUIsQ0FBQTtJQUNqQix1Q0FBbUIsQ0FBQTtBQUNyQixDQUFDLEVBSEksZ0JBQWdCLEtBQWhCLGdCQUFnQixRQUdwQjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFLSDtJQUNBO0lBQ0E7SUFObkI7O09BRUc7SUFDSCxZQUNtQixjQUE4QixFQUM5QixjQUE4QixFQUM5Qix3QkFBa0Q7UUFGbEQsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5Qiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO0lBQ2xFLENBQUM7SUFDSjs7T0FFRztJQUNILE1BQU0sR0FBRyxLQUFLLEVBQUUsU0FBNEIsRUFBRSxXQUF5QixFQUFFLEVBQUU7UUFDekUsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRWxDLE1BQU0sY0FBYyxHQUFhLEVBQUUsQ0FBQztRQUNwQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ2hDLGNBQWMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztZQUMxQyxjQUFjLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDdkMsSUFBSSxXQUFXLEVBQUUsaUJBQWlCLEVBQUU7Z0JBQ2xD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LEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQzlELE1BQU0sQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNsRDtnQkFDRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUM3QyxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUM5RCxNQUFNLENBQUMsZUFBZSxDQUFDLGFBQWEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDdEQ7YUFDRjtTQUNGO0lBQ0gsQ0FBQyxDQUFDO0NBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgcmVhZGxpbmUgZnJvbSAncmVhZGxpbmUnO1xuaW1wb3J0IHtcbiAgQmFja2VuZERlcGxveWVyLFxuICBEZXBsb3lQcm9wcyxcbiAgRGVwbG95UmVzdWx0LFxuICBEZXN0cm95UmVzdWx0LFxufSBmcm9tICcuL2Nka19kZXBsb3llcl9zaW5nbGV0b25fZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBDZGtFcnJvck1hcHBlciB9IGZyb20gJy4vY2RrX2Vycm9yX21hcHBlci5qcyc7XG5pbXBvcnQge1xuICBCYWNrZW5kSWRlbnRpZmllcixcbiAgdHlwZSBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZExvY2F0b3IsXG4gIENES0NvbnRleHRLZXksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IGRpcm5hbWUgfSBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBDb21tYW5kcyB0aGF0IGNhbiBiZSBpbnZva2VkXG4gKi9cbmVudW0gSW52b2thYmxlQ29tbWFuZCB7XG4gIERFUExPWSA9ICdkZXBsb3knLFxuICBERVNUUk9ZID0gJ2Rlc3Ryb3knLFxufVxuXG4vKipcbiAqIEludm9rZXMgQ0RLIGNvbW1hbmQgdmlhIGV4ZWNhXG4gKi9cbmV4cG9ydCBjbGFzcyBDREtEZXBsb3llciBpbXBsZW1lbnRzIEJhY2tlbmREZXBsb3llciB7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgaW5zdGFuY2Ugb2YgQ0RLRGVwbG95ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RrRXJyb3JNYXBwZXI6IENka0Vycm9yTWFwcGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZExvY2F0b3I6IEJhY2tlbmRMb2NhdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGFja2FnZU1hbmFnZXJDb250cm9sbGVyOiBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXJcbiAgKSB7fVxuICAvKipcbiAgICogSW52b2tlcyBjZGsgZGVwbG95IGNvbW1hbmRcbiAgICovXG4gIGRlcGxveSA9IGFzeW5jIChiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLCBkZXBsb3lQcm9wcz86IERlcGxveVByb3BzKSA9PiB7XG4gICAgYXdhaXQgdGhpcy5pbnZva2VUc2MoZGVwbG95UHJvcHMpO1xuXG4gICAgY29uc3QgY2RrQ29tbWFuZEFyZ3M6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGJhY2tlbmRJZC50eXBlID09PSAnc2FuZGJveCcpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0taG90c3dhcC1mYWxsYmFjaycpO1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1tZXRob2Q9ZGlyZWN0Jyk7XG4gICAgICBpZiAoZGVwbG95UHJvcHM/LnNlY3JldExhc3RVcGRhdGVkKSB7XG4gICAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goXG4gICAgICAgICAgJy0tY29udGV4dCcsXG4gICAgICAgICAgYHNlY3JldExhc3RVcGRhdGVkPSR7ZGVwbG95UHJvcHMuc2VjcmV0TGFzdFVwZGF0ZWQuZ2V0VGltZSgpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cnlJbnZva2VDZGsoXG4gICAgICBJbnZva2FibGVDb21tYW5kLkRFUExPWSxcbiAgICAgIGJhY2tlbmRJZCxcbiAgICAgIGNka0NvbW1hbmRBcmdzXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogSW52b2tlcyBjZGsgZGVzdHJveSBjb21tYW5kXG4gICAqL1xuICBkZXN0cm95ID0gYXN5bmMgKGJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIpID0+IHtcbiAgICByZXR1cm4gdGhpcy50cnlJbnZva2VDZGsoSW52b2thYmxlQ29tbWFuZC5ERVNUUk9ZLCBiYWNrZW5kSWQsIFsnLS1mb3JjZSddKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcHBlciBmb3IgdGhlIGNoaWxkIHByb2Nlc3MgZXhlY3V0b3IuIEhlbHBzIGluIHVuaXQgdGVzdGluZyBhcyBub2RlOnRlc3QgZnJhbWV3b3JrXG4gICAqIGRvZXNuJ3QgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gbW9jayBleHBvcnRlZCBmdW5jdGlvbnMgbGlrZSBgZXhlY2FgIGFzIG9mIHJpZ2h0IG5vdy5cbiAgICovXG4gIGV4ZWN1dGVDb21tYW5kID0gYXN5bmMgKFxuICAgIGNvbW1hbmRBcmdzOiBzdHJpbmdbXSxcbiAgICBvcHRpb25zOiB7IHByaW50U3Rkb3V0OiBib29sZWFuIH0gPSB7IHByaW50U3Rkb3V0OiB0cnVlIH1cbiAgKSA9PiB7XG4gICAgLy8gV2UgbGV0IHRoZSBzdGRvdXQgYW5kIHN0ZGluIGluaGVyaXQgYW5kIHN0cmVhbWVkIHRvIHBhcmVudCBwcm9jZXNzIGJ1dCBwaXBlXG4gICAgLy8gdGhlIHN0ZGVyciBhbmQgdXNlIGl0IHRvIHRocm93IG9uIGZhaWx1cmUuIFRoaXMgaXMgdG8gcHJldmVudCBhY3R1YWxcbiAgICAvLyBhY3Rpb25hYmxlIGVycm9ycyBiZWluZyBoaWRkZW4gYW1vbmcgdGhlIHN0ZG91dC4gTW9yZW92ZXIgZXhlY2EgZXJyb3JzIGFyZVxuICAgIC8vIHVzZWxlc3Mgd2hlbiBjYWxsaW5nIENMSXMgdW5sZXNzIHlvdSBtYWRlIGV4ZWNhIGNhbGxpbmcgZXJyb3IuXG4gICAgbGV0IGFnZ3JlZ2F0ZWRTdGRlcnIgPSAnJztcbiAgICBjb25zdCBhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSgpO1xuICAgIGFnZ3JlZ2F0b3JTdGRlcnJTdHJlYW0uX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgYWdncmVnYXRlZFN0ZGVyciArPSBjaHVuaztcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvY2VzcyA9IHRoaXMucGFja2FnZU1hbmFnZXJDb250cm9sbGVyLnJ1bldpdGhQYWNrYWdlTWFuYWdlcihcbiAgICAgIGNvbW1hbmRBcmdzLFxuICAgICAgcHJvY2Vzcy5jd2QoKSxcbiAgICAgIHtcbiAgICAgICAgc3RkaW46ICdpbmhlcml0JyxcbiAgICAgICAgc3Rkb3V0OiAncGlwZScsXG4gICAgICAgIHN0ZGVycjogJ3BpcGUnLFxuICAgICAgICAvLyBQaXBpbmcgdGhlIG91dHB1dCBieSBkZWZhdWx0IHN0cmlwcyBvZmYgdGhlIGNvbG9yLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgY29sb3IgYmVpbmcgcGlwZWQgdG8gcGFyZW50IHByb2Nlc3MuXG4gICAgICAgIGV4dGVuZEVudjogdHJ1ZSxcbiAgICAgICAgZW52OiB7IEZPUkNFX0NPTE9SOiAnMScgfSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY2hpbGRQcm9jZXNzLnN0ZGVycj8ucGlwZShhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtKTtcblxuICAgIGlmIChvcHRpb25zPy5wcmludFN0ZG91dCkge1xuICAgICAgY2hpbGRQcm9jZXNzLnN0ZG91dD8ucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2RrT3V0cHV0ID0geyBkZXBsb3ltZW50VGltZXM6IHt9IH07XG4gICAgaWYgKGNoaWxkUHJvY2Vzcy5zdGRvdXQpIHtcbiAgICAgIGF3YWl0IHRoaXMucG9wdWxhdGVDREtPdXRwdXRGcm9tU3Rkb3V0KGNka091dHB1dCwgY2hpbGRQcm9jZXNzLnN0ZG91dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNoaWxkUHJvY2VzcztcbiAgICAgIHJldHVybiBjZGtPdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHN3YWxsb3cgZXhlY2EgZXJyb3Igd2hpY2ggaXMgbW9zdCBvZiB0aGUgdGltZSBub2lzZSAoYmFzaWNhbGx5IGNoaWxkIGV4aXRlZCB3aXRoIGV4aXQgY29kZS4uLilcbiAgICAgIC8vIGJ1YmJsaW5nIHRoaXMgdXAgdG8gY3VzdG9tZXJzIGFkZCBjb25mdXNpb24gKEN1c3RvbWVycyBkb24ndCBuZWVkIHRvIGtub3cgd2UgYXJlIHJ1bm5pbmcgSVBDIGNhbGxzXG4gICAgICAvLyBhbmQgdGhlaXIgZXhpdCBjb2RlcyBwcmludGVkIHdoaWxlIHNhbmRib3ggY29udGludWUgdG8gcnVuKS4gSGVuY2Ugd2UgZXhwbGljaXRseSBkb24ndCBwYXNzIGVycm9yIGluIHRoZSBjYXVzZVxuICAgICAgLy8gcmF0aGVyIHRocm93IHRoZSBlbnRpcmUgc3RkZXJyIGZvciBjbGllbnRzIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyB3aXRoIGl0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGFnZ3JlZ2F0ZWRTdGRlcnIpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGludm9rZVRzYyA9IGFzeW5jIChkZXBsb3lQcm9wcz86IERlcGxveVByb3BzKSA9PiB7XG4gICAgaWYgKCFkZXBsb3lQcm9wcz8udmFsaWRhdGVBcHBTb3VyY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ3RzYycsXG4gICAgICAgICAgJy0tc2hvd0NvbmZpZycsXG4gICAgICAgICAgJy0tcHJvamVjdCcsXG4gICAgICAgICAgZGlybmFtZSh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKSxcbiAgICAgICAgXSxcbiAgICAgICAgeyBwcmludFN0ZG91dDogZmFsc2UgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgd2UgY2Fubm90IGxvYWQgdHMgY29uZmlnLCB0dXJuIG9mZiB0eXBlIGNoZWNraW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKFtcbiAgICAgICAgJ3RzYycsXG4gICAgICAgICctLW5vRW1pdCcsXG4gICAgICAgICctLXNraXBMaWJDaGVjaycsXG4gICAgICAgIC8vIHBvaW50aW5nIHRoZSBwcm9qZWN0IGFyZyB0byB0aGUgYW1wbGlmeSBiYWNrZW5kIGRpcmVjdG9yeSB3aWxsIHVzZSB0aGUgdHNjb25maWcgcHJlc2VudCBpbiB0aGF0IGRpcmVjdG9yeVxuICAgICAgICAnLS1wcm9qZWN0JyxcbiAgICAgICAgZGlybmFtZSh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKSxcbiAgICAgIF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3IoXG4gICAgICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ1R5cGVTY3JpcHQgdmFsaWRhdGlvbiBjaGVjayBmYWlsZWQsIGNoZWNrIHlvdXIgYmFja2VuZCBkZWZpbml0aW9uJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjYWxscyBpbnZva2VDREsgYW5kIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2hcbiAgICovXG4gIHByaXZhdGUgdHJ5SW52b2tlQ2RrID0gYXN5bmMgKFxuICAgIGludm9rYWJsZUNvbW1hbmQ6IEludm9rYWJsZUNvbW1hbmQsXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBhZGRpdGlvbmFsQXJndW1lbnRzPzogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxEZXBsb3lSZXN1bHQgfCBEZXN0cm95UmVzdWx0PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludm9rZUNkayhcbiAgICAgICAgaW52b2thYmxlQ29tbWFuZCxcbiAgICAgICAgYmFja2VuZElkLFxuICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgdGhpcy5jZGtFcnJvck1hcHBlci5nZXRBbXBsaWZ5RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgQ0RLIGNvbW1hbmRcbiAgICovXG4gIHByaXZhdGUgaW52b2tlQ2RrID0gYXN5bmMgKFxuICAgIGludm9rYWJsZUNvbW1hbmQ6IEludm9rYWJsZUNvbW1hbmQsXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBhZGRpdGlvbmFsQXJndW1lbnRzPzogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxEZXBsb3lSZXN1bHQgfCBEZXN0cm95UmVzdWx0PiA9PiB7XG4gICAgLy8gQmFzaWMgYXJnc1xuICAgIGNvbnN0IGNka0NvbW1hbmRBcmdzID0gW1xuICAgICAgJ2NkaycsXG4gICAgICBpbnZva2FibGVDb21tYW5kLnRvU3RyaW5nKCksXG4gICAgICAvLyBUaGlzIGlzIHVuZm9ydHVuYXRlLiBDREsgd3JpdGVzIGV2ZXJ5dGhpbmcgdG8gc3RkZXJyIHdpdGhvdXQgYC0tY2lgIGZsYWcgYW5kIHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB0d28uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy83NzE3IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAnLS1jaScsXG4gICAgICAnLS1hcHAnLFxuICAgICAgdGhpcy5wYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIuZ2V0Q29tbWFuZChbXG4gICAgICAgICd0c3gnLFxuICAgICAgICB0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpLFxuICAgICAgXSksXG4gICAgICAnLS1hbGwnLFxuICAgICAgJy0tb3V0cHV0JyxcbiAgICAgICcuYW1wbGlmeS9hcnRpZmFjdHMvY2RrLm91dCcsXG4gICAgXTtcblxuICAgIC8vIEFkZCBjb250ZXh0IGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGNka0NvbW1hbmRBcmdzLnB1c2goXG4gICAgICAnLS1jb250ZXh0JyxcbiAgICAgIGAke0NES0NvbnRleHRLZXkuQkFDS0VORF9OQU1FU1BBQ0V9PSR7YmFja2VuZElkLm5hbWVzcGFjZX1gLFxuICAgICAgJy0tY29udGV4dCcsXG4gICAgICBgJHtDREtDb250ZXh0S2V5LkJBQ0tFTkRfTkFNRX09JHtiYWNrZW5kSWQubmFtZX1gXG4gICAgKTtcblxuICAgIGlmIChiYWNrZW5kSWQudHlwZSAhPT0gJ3NhbmRib3gnKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKCctLXJlcXVpcmUtYXBwcm92YWwnLCAnbmV2ZXInKTtcbiAgICB9XG5cbiAgICBjZGtDb21tYW5kQXJncy5wdXNoKFxuICAgICAgJy0tY29udGV4dCcsXG4gICAgICBgJHtDREtDb250ZXh0S2V5LkRFUExPWU1FTlRfVFlQRX09JHtiYWNrZW5kSWQudHlwZX1gXG4gICAgKTtcblxuICAgIGlmIChhZGRpdGlvbmFsQXJndW1lbnRzKSB7XG4gICAgICBjZGtDb21tYW5kQXJncy5wdXNoKC4uLmFkZGl0aW9uYWxBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKGNka0NvbW1hbmRBcmdzKTtcbiAgfTtcblxuICBwcml2YXRlIHBvcHVsYXRlQ0RLT3V0cHV0RnJvbVN0ZG91dCA9IGFzeW5jIChcbiAgICBvdXRwdXQ6IERlcGxveVJlc3VsdCB8IERlc3Ryb3lSZXN1bHQsXG4gICAgc3Rkb3V0OiBzdHJlYW0uUmVhZGFibGVcbiAgKSA9PiB7XG4gICAgY29uc3QgcmVnZXhUb3RhbFRpbWUgPSAv4pyoIHsyfVRvdGFsIHRpbWU6IChcXGQqXFwuKlxcZCopcy4qLztcbiAgICBjb25zdCByZWdleFN5bnRoVGltZSA9IC/inKggezJ9U3ludGhlc2lzIHRpbWU6IChcXGQqXFwuKlxcZCopcy87XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHN0ZG91dCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIHJlYWRlcikge1xuICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ+KcqCcpKSB7XG4gICAgICAgIC8vIEdvb2QgY2hhbmNlIHRoYXQgaXQgY29udGFpbnMgdGltaW5nIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGxpbmUubWF0Y2gocmVnZXhUb3RhbFRpbWUpO1xuICAgICAgICBpZiAodG90YWxUaW1lICYmIHRvdGFsVGltZS5sZW5ndGggPiAxICYmICFpc05hTigrdG90YWxUaW1lWzFdKSkge1xuICAgICAgICAgIG91dHB1dC5kZXBsb3ltZW50VGltZXMudG90YWxUaW1lID0gK3RvdGFsVGltZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzeW50aFRpbWUgPSBsaW5lLm1hdGNoKHJlZ2V4U3ludGhUaW1lKTtcbiAgICAgICAgaWYgKHN5bnRoVGltZSAmJiBzeW50aFRpbWUubGVuZ3RoID4gMSAmJiAhaXNOYU4oK3N5bnRoVGltZVsxXSkpIHtcbiAgICAgICAgICBvdXRwdXQuZGVwbG95bWVudFRpbWVzLnN5bnRoZXNpc1RpbWUgPSArc3ludGhUaW1lWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIl19